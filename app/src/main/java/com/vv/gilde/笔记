1.Glide资源封装
Key  -- 对Value的唯一性描述
Value -- Bitmap的封装（+1，-1，释放）

2.活动缓存
1.回收机制：GC扫描的时候回收， 弱引用的监听（容器 移除） 【被动移除】
2.手动移除
3.专门关闭线程
4.添加
5.Value 和 Callback 进行了关联




------ ##################### 1
总结：
第一次的时候，去网络下载图片，保存到磁盘缓存中（/sd/disk_lru_cache_dir/key）
第二次的时候，直接再活动缓存中，找到了资源
第三次的时候，直接再活动缓存中，找到了资源
第N次的时候，直接再活动缓存中，找到了资源

把Activity给返回回去的时候，进行释放，活动缓存的释放
又一次加载的时候，从内存缓存中获取了
下一次加载的时候，就是从活动缓存获取了
第二次的时候，直接再活动缓存中，找到了资源
第三次的时候，直接再活动缓存中，找到了资源
第N次的时候，直接再活动缓存中，找到了资源

把App给杀掉
整个活动缓存，整个内存缓存，都没有了 （运行内存缓存）
首次冷启动 所以从磁盘缓存中获取
第二次的时候，直接再活动缓存中，找到了资源
第三次的时候，直接再活动缓存中，找到了资源
第N次的时候，直接再活动缓存中，找到了资源

------ ##################### 2
LUR -- DiskLruCache，LruCache

------ ##################### 3
为什么有了 内存缓存 还需要 活动缓存 ？
答：
  活动：正在使用的图片，都放在活动缓存 （弱引用 GC 没有使用了 已回收 被动回收） 【资源封装 Key Value】

  内存：LRU管理的，临时存放 活动缓存 不使用的Value（LRU最少使用算法） 【资源封装 Key Value】

  为什么要活动缓存？
  内存：LRU管理的，maxsize，如果最少使用，内部算法会回收（不安全，不稳定）

  你正在使用的图片---【活动缓存】如果不用了 才会扫描时回收，[存入 移除 非常快]

------ ##################### 4
为什么Glide源码一定要发生一次Handler
@1 ActivityThread
@2 构造
@3 事务 提交 实际上 源码 Handler 添加 到队列的

------ ##################### 5
活动缓存，用到了弱引用的监听

------ ##################### 6
Glide 生命周期管理 很独到

------ ##################### 7
Glide资源封装的引用计数 ，游戏引擎，NDK用引用计数做功能

------ ##################### 8
Glide缓存流程图

